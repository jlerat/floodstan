
// Correlation parameterisation
// 1=Gumbel, 2=Clayton, 3=Gaussian
real corr2param(int copula, real rho) {

    real rho_min = 0.01;
    real rho_max = 0.95;

    // Lower threshold for Gaussian copula due to 
    // limitation in cdf approximation algorithm
    if(copula==3)
        rho_max = 0.8;

    if(rho < rho_min)
        reject("Copula ", copula, ": rho (", rho, ") < ", rho_min);
    if(rho > rho_max)
        reject("Copula ", copula, ": rho (", rho, ") > ", rho_max);

    if(copula==1) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 172
        return 1.0/(1.0-rho);
    }

    else if (copula==2) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 168
        return 2.0*rho/(1.0-rho);
    }

    else if (copula==3) {
        // Using Kendall Tau as parameter
        return sin(pi()*rho/2.0);
    }

    return not_a_number();
}


// ------- Copula functions -----------------------------
// 1=Gumbel, 2=Clayton, 3=Gaussian

real copula_lcdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta)+pow(y, theta);
        return sum(-pow(expsum, 1.0/theta));
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] x = pow(uv[:, 1], -theta);
        vector[N] y = pow(uv[:, 2], -theta);
        return sum(-log(x+y-1)/theta);
    }

    else if (copula==3) {
        // Gaussian copula

        // Translation of the matlab code from Alan Genz
        // https://www.math.wsu.edu/faculty/genz/software/matlab/bvn.m
        // Note that this code was supposed to work for correlation < 0.925
        // we are using it upto correlation = 0.951
        real r = corr2param(copula, rho);
        real tp = 2*pi();
        vector[N] h = -inv_Phi(uv[:, 1]);
        vector[N] k = -inv_Phi(uv[:, 2]);
        vector[N] hk = h.*k;

        array[10] real w = zeros_array(10);
        array[10] real x = zeros_array(10);

        if(abs(r) < 0.3){
            // Gauss Legendre points and weights, n =  6
            w[1:3] = {0.1713244923791705, 0.3607615730481384, 0.4679139345726904};
            x[1:3] = {0.9324695142031522, 0.6612093864662647, 0.2386191860831970};
        }
        else if(abs(r) < 0.75) {
            // Gauss Legendre points and weights, n = 12
            w[1:3] = {0.04717533638651177, 0.1069393259953183, 0.1600783285433464};
            w[4:6] = {0.2031674267230659, 0.2334925365383547, 0.2491470458134029};

            x[1:3] = {0.9815606342467191, 0.9041172563704750, 0.7699026741943050};
            x[4:6] = {0.5873179542866171, 0.3678314989981802, 0.1252334085114692};
        }   
        else {
            // Gauss Legendre points and weights, n = 20
            w[1:3] = {0.01761400713915212, .04060142980038694, 0.06267204833410906};
            w[4:6] = {0.08327674157670475, 0.1019301198172404, 0.1181945319615184};
            w[7:9] = {0.1316886384491766, 0.1420961093183821, 0.1491729864726037};
            w[10] = 0.1527533871307259;

            x[1:3] = {0.9931285991850949, 0.9639719272779138, 0.9122344282513259};
            x[4:6] = {0.8391169718222188, 0.7463319064601508, 0.6360536807265150};
            x[7:9] = {0.5108670019508271, 0.3737060887154196, 0.2277858511416451};
            x[10] = 0.07652652113349733;
        }

        vector[N] hs = (h.*h+k.*k)/2;
        real asr = asin(r)/2;
        real sn;
        int j;
        vector[N] bvn = zeros_vector(N);
        for(i in 1:20){
            if(i<=10) {
                j = i;
                sn = sin(asr*(1+x[j]));
            }    
            else {
                j = i-10;
                sn = sin(asr*(1-x[j]));
            }    
            bvn = bvn + exp((sn*hk-hs)/(1-sn*sn))*w[j];
        }

        return sum(log(bvn*asr/tp+Phi(-h).*Phi(-k)));
    }

    return not_a_number();
}

real copula_lpdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta)+pow(y, theta);
        vector[N] exppow = pow(expsum, 1.0/theta);
        return sum(-exppow
                    +log(exppow+theta-1.0)
                    +(1.0/theta-2.0)*log(expsum)
                    +(theta-1.0)*log(x.*y)
                    +x+y);
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] expsum = pow(uv[:, 1], -theta)+pow(uv[:, 2], -theta)-1;
        return N*log(1.0+theta)+sum(-(theta+1.0)*log(uv[:, 1].*uv[:, 2])
                                        -(2+1.0/theta)*log(expsum));
    }

    else if (copula==3) {
        // Gaussian copula
        real theta = corr2param(copula, rho);
        real r2 = 1-theta*theta;
        vector[N] p = inv_Phi(uv[:, 1]);
        vector[N] q = inv_Phi(uv[:, 2]);
        vector[N] s2 = p.*p+q.*q;
        vector[N] z = s2-2*theta*p.*q;
        return -log(r2)*N/2+sum(-z/r2/2+s2/2);
    }
    
    return not_a_number();
}

real copula_lpdf_conditional(vector ucond, real v, int copula, real rho){
    int N = rows(ucond);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(ucond);
        real y = -log(v);
        return sum(x-pow(pow(x, theta)+pow(y, theta), 1./theta)
                                 +(1/theta-1)*log(1+pow(y./x, theta)));
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] expm1 = 1+pow(ucond, theta)*(pow(v, -theta)-1);
        return sum(-(1.0+1.0/theta)*log(expm1));
    }

    else if (copula==3) {
        // Gaussian copula
        real theta = corr2param(copula, rho);
        vector[N] pcensor = inv_Phi(ucond);
        real q = inv_Phi(v);
        return sum(log(Phi((q-theta*pcensor)/sqrt(1-theta*theta))));
    }

    return not_a_number();
}

