
// Correlation parameterisation
// 1=Gumbel, 2=Clayton, 3=Gaussian
real corr2param(int copula, real rho) {

    real rho_min = 0.01;
    real rho_max = 0.95;

    // Lower threshold for Gaussian copula due to 
    // limitation in cdf approximation algorithm
    if(copula==3)
        rho_max = 0.85;

    if(rho < rho_min)
        reject("Copula ", copula, ": rho (", rho, ") < ", rho_min);
    if(rho > rho_max)
        reject("Copula ", copula, ": rho (", rho, ") > ", rho_max);

    if(copula==1) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 172
        return 1.0/(1.0-rho);
    }

    else if (copula==2) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 168
        return 2.0*rho/(1.0-rho);
    }

    else if (copula==3) {
        // Using Kendall Tau as parameter
        return sin(pi()*rho/2.0);
    }

    return not_a_number();
}


// ------- Copula functions -----------------------------
// 1=Gumbel, 2=Clayton, 3=Gaussian

real copula_lcdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta)+pow(y, theta);
        return sum(-pow(expsum, 1.0/theta));
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] x = pow(uv[:, 1], -theta);
        vector[N] y = pow(uv[:, 2], -theta);
        return sum(-log(x+y-1)/theta);
    }

    else if (copula==3) {
        // Gaussian copula

        // Adapted from
        // https://mc-stan.org/docs/stan-users-guide/custom-probability.html

        real r = corr2param(copula, rho);
        vector[N] z1 = inv_Phi(uv[:, 1]);
        vector[N] z2 = inv_Phi(uv[:, 2]);

        real denom = sqrt((1 + r) * (1 - r));
        vector[N] a1 = (z2 ./ z1 - r) ./ denom;
        vector[N] a2 = (z1 ./ z2 - r) ./ denom;
        vector[N] product = z1 .* z2;
        vector[N] cdf;

        for(i in 1:N) {
            real delta = product[i] < 0 || (product[i] == 0 && (z1[i] + z2[i]) < 0);
            cdf[i] = 0.5 * (uv[i, 1] + uv[i, 2] - delta)
                         - owens_t(z1[i], a1[i]) - owens_t(z2[i], a2[i]);
        }                 
        return sum(log(cdf));
    }

    return not_a_number();
}

real copula_lpdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta)+pow(y, theta);
        vector[N] exppow = pow(expsum, 1.0/theta);
        return sum(-exppow
                    +log(exppow+theta-1.0)
                    +(1.0/theta-2.0)*log(expsum)
                    +(theta-1.0)*log(x.*y)
                    +x+y);
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] expsum = pow(uv[:, 1], -theta)+pow(uv[:, 2], -theta)-1;
        return N*log(1.0+theta)+sum(-(theta+1.0)*log(uv[:, 1].*uv[:, 2])
                                        -(2+1.0/theta)*log(expsum));
    }

    else if (copula==3) {
        // Gaussian copula
        real theta = corr2param(copula, rho);
        real r2 = 1-theta*theta;
        vector[N] p = inv_Phi(uv[:, 1]);
        vector[N] q = inv_Phi(uv[:, 2]);
        vector[N] s2 = p.*p+q.*q;
        vector[N] z = s2-2*theta*p.*q;
        return -log(r2)*N/2+sum(-z/r2/2+s2/2);
    }
    
    return not_a_number();
}

real copula_lpdf_conditional(vector ucond, real v, int copula, real rho){
    int N = rows(ucond);

    if(copula==1) {
        // Gumbel copula
        real theta = corr2param(copula, rho);
        vector[N] x = -log(ucond);
        real y = -log(v);
        return sum(x-pow(pow(x, theta)+pow(y, theta), 1./theta)
                                 +(1/theta-1)*log(1+pow(y./x, theta)));
    }

    else if (copula==2) {
        // Clayton copula
        real theta = corr2param(copula, rho);
        vector[N] expm1 = 1+pow(ucond, theta)*(pow(v, -theta)-1);
        return sum(-(1.0+1.0/theta)*log(expm1));
    }

    else if (copula==3) {
        // Gaussian copula
        real theta = corr2param(copula, rho);
        vector[N] pcensor = inv_Phi(ucond);
        real q = inv_Phi(v);
        return sum(log(Phi((q-theta*pcensor)/sqrt(1-theta*theta))));
    }

    return not_a_number();
}

