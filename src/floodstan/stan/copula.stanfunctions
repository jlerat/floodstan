
// Correlation parameterisation
// 1=Gumbel, 2=Clayton, 3=Gaussian
real corr2param(int copula, real rho) {

    // Thresholds slightly bigger than in the python code
    // to allow small discrepencies
    real rho_min = 0.005;
    real rho_max = 0.955;

    if(rho < rho_min)
        reject("Copula ", copula, ": rho (", rho, ") < ", rho_min);
    if(rho > rho_max)
        reject("Copula ", copula, ": rho (", rho, ") > ", rho_max);

    // Kendall Tau as parameter (i.e. rho = kendall tau)
    if(copula==1) {
        // See Joe (2014), page 172
        return 1. / (1. - rho);
    }

    else if (copula==2) {
        // See Joe (2014), page 168
        return 2. * rho / (1. - rho);
    }

    else if (copula==3) {
        // See Joe (2014), page 164
        return sin(pi() * rho / 2.);
    }

    return not_a_number();
}


// ------- Copula functions -----------------------------
// 1=Gumbel, 2=Clayton, 3=Gaussian

real copula_lcdf(matrix uv, int copula, real rho){
    int N = rows(uv);
    real theta = corr2param(copula, rho);

    if(copula==1) {
        // Gumbel copula
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta)+pow(y, theta);
        return sum(-pow(expsum, 1. / theta));
    }

    else if (copula==2) {
        // Clayton copula
        vector[N] x = pow(uv[:, 1], -theta);
        vector[N] y = pow(uv[:, 2], -theta);
        return sum(-log(x + y - 1) / theta);
    }

    else if (copula==3) {
        // Gaussian copula

        // Adapted from
        // https://mc-stan.org/docs/stan-users-guide/custom-probability.html

        vector[N] z1 = inv_Phi(uv[:, 1]);
        vector[N] z2 = inv_Phi(uv[:, 2]);

        real denom = sqrt((1 + theta) * (1 - theta));
        vector[N] a1 = (z2 ./ z1 - theta) ./ denom;
        vector[N] a2 = (z1 ./ z2 - theta) ./ denom;
        vector[N] product = z1 .* z2;
        vector[N] cdf;

        for(i in 1:N) {
            real delta = product[i] < 0 || (product[i] == 0 && (z1[i] + z2[i]) < 0);
            cdf[i] = 0.5 * (uv[i, 1] + uv[i, 2] - delta)
                         - owens_t(z1[i], a1[i]) - owens_t(z2[i], a2[i]);
        }                 
        return sum(log(cdf));
    }

    return not_a_number();
}

real copula_lpdf(matrix uv, int copula, real rho){
    int N = rows(uv);
    real theta = corr2param(copula, rho);

    if(copula==1) {
        // Gumbel copula
        vector[N] x = -log(uv[:, 1]);
        vector[N] y = -log(uv[:, 2]);
        vector[N] expsum = pow(x, theta) + pow(y, theta);
        vector[N] exppow = pow(expsum, 1. / theta);

        return sum(- exppow
                    + log(exppow + theta - 1.)
                    + (1. / theta - 2.) * log(expsum)
                    + (theta - 1.) * log(x .* y)
                    + x + y);
    }

    else if (copula==2) {
        // Clayton copula
        vector[N] expsum = pow(uv[:, 1], -theta) + pow(uv[:, 2], -theta) - 1;
        return N * log(1. + theta)
               + sum(-(theta + 1.) * log(uv[:, 1] .* uv[:, 2])
                     -(2. + 1. / theta) * log(expsum));
    }

    else if (copula==3) {
        // Gaussian copula
        real r2 = 1. - theta * theta;
        vector[N] p = inv_Phi(uv[:, 1]);
        vector[N] q = inv_Phi(uv[:, 2]);
        vector[N] s2 = p .* p + q .* q;
        vector[N] z = s2 - 2. * theta * p .* q;
        return -log(r2) * N/2 + sum(-z / r2 / 2. + s2 / 2.);
    }
    
    return not_a_number();
}

real copula_lpdf_conditional(vector ucond, real v, int copula, real rho){
    int N = rows(ucond);
    real theta = corr2param(copula, rho);

    if(copula==1) {
        // Gumbel copula
        vector[N] x = -log(ucond);
        real y = -log(v);
        return sum(x - pow(pow(x, theta) + pow(y, theta), 1. / theta)
                           + (1. / theta - 1.) * log(1. + pow( y ./ x, theta)));
    }

    else if (copula==2) {
        // Clayton copula
        vector[N] expm1 = 1. + pow(ucond, theta) * (pow(v, -theta) - 1.);
        return sum(-(1. + 1. / theta) * log(expm1));
    }

    else if (copula==3) {
        // Gaussian copula
        vector[N] pcensor = inv_Phi(ucond);
        real q = inv_Phi(v);
        return sum(log(Phi((q - theta * pcensor) / sqrt(1. - theta * theta))));
    }

    return not_a_number();
}
