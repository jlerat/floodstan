 real sign(real x) {
    return x > 0 ? 1 : (x < 0 ? -1 : 0);
 }

// -------------- GEV distribution ------------------------------
// tau Bounds when kappa > 0 : [ymax-alpha/kapp, +infty[
// tau Bounds when kappa < 0 : ]-infty, ycensor-alpha/kapp]

real gev_lpdf(vector y, real tau, real alpha, real kappa){
    int N = rows(y);
    real logalpha = log(alpha);
    vector[N] u = (y-tau)/alpha;
    vector[N] v;

    // Threshold to transition from GEV to Gumbel
    real GEV2Gumbel_transition = 1e-10;

    real y0 = tau+alpha/kappa;
    if(kappa < 0) {
        real ymin = min(y);
        if(ymin < y0)
            reject("min(y) (", ymin, ") is lower than y0 (", y0, ").");
    }
    else {
        real ymax = max(y);
        if(ymax > y0)
            reject("max(y) (", ymax, ") is greater than y0 (", y0, ").");
    }
    
    if(abs(kappa) > GEV2Gumbel_transition) {
        // This is GEV log pdf
        v = -pow(1 - kappa * u, 1 / kappa);
        return -N * logalpha + sum(v + (1 / kappa - 1) * log(1 - kappa * u));

    } else {
        // This Gumbel log pdf
        return -N * logalpha - sum(u + exp(-u));
    }
}

real gev_lcdf(real y, real tau, real alpha, real kappa){
    real u = (y - tau) / alpha;
    real v;
   
    // Threshold to transition from GEV to Gumbel
    real GEV2Gumbel_transition = 1e-10;

    if(abs(kappa) > GEV2Gumbel_transition) {
        // No parameter constraint here, already taken care of in lpdf
        return -pow(1. - kappa * u, 1. / kappa);

    } else {
        return -exp(-u);
    }
}

// -------------- Pearson3 and LogPearson3 distributions -------------
// Pearson3 log pdf and cdf - equivalent to a shifted Gamma distribution
real pearson3_lpdf(vector u, real m, real s, real g) {
    int N = rows(u);

    // Using transition from Pearson3 to Normal as done in scipy:
    // https://github.com/scipy/scipy/blob/2e5883ef7af4f5ed4a5b80a1759a45e43163bf3f/scipy/stats/_continuous_distns.py#L6810
    // however, used a higher threshold to minimize numerical difficulties
    // We use 0.0001, whereas scipy threshold is 0.000016
    real norm2pearson_transition = 0.0001; 

    real abs_g = abs(g);
    real sign_g = sign(g);
   
    if(abs_g > norm2pearson_transition) {
        // Original LogPearson3 parameterisation
        real alpha = 4 / g / g;
        real beta = 2 / g / s;
        real abs_beta = abs(beta);
        real tau = m - alpha / beta;

        // Check inputs
        vector[N] usng = sign(g) * (u - tau);

        // Constraints related to distribution support
        real umin = min(usng);
        if(umin < 0) 
            reject("umin(", umin, ")<0 with m=", m, " s=", s, " g=", g);

        return gamma_lpdf(usng | alpha, abs(beta));
        
        // if(alpha > 1) {
        //     // Algorithm to extend gamma distribution and allow values of u < tau
        //     // with a very low pdf. Only applied if alpha > 1, otherwise
        //     // Gamma pdf at 0 is not 0, hence it cannot be extended in this way.
        //     // Alpha > 1 is not possible because of the bounds [-2, 2] set
        //     // on the shape factor in the python code.
        //     real neg_transition = 1e-10; 
        //     
        //     // .. value of gamma pdf at this point
        //     real gamma_thresh = gamma_lpdf(neg_transition | alpha, abs_beta);
        //     real lgamma_thresh = log(gamma_thresh);

        //     // .. value of the derivative of the gamma pdf at this point
        //     real dgamma_thresh = (alpha - 1. - neg_transition / abs_beta) 
        //                             * abs_beta / neg_transition * gamma_thresh;

        //     // Replace gamma pdf with an exponential and a fifth order
        //     // polynomial to avoid numerical problems
        //     real lpdf_sum = 0.;
        //     for(i in 1:N) {
        //         real value = sign_g * (u[i] - tau);
        //         if(value < neg_transition) {
        //             real x = dgamma_thresh / gamma_thresh * (value - neg_transition);
        //             real x5 = x * x;
        //             x5 *= x5;
        //             x5 *= x;
        //             lpdf_sum += lgamma_thresh + x + x5;
        //         } else {
        //             lpdf_sum += gamma_lpdf(value | alpha, abs_beta);
        //         }
        //     }
        //     return lpdf_sum;

        // } else {
        //     return gamma_lpdf(sign_g * (u - tau) | alpha, abs_beta);
        // }

    } else {
        return normal_lpdf(u | m, s);
    }
}

real pearson3_cdf(real u, real m, real s, real g){
    
    real norm2pearson_transition = 0.0001; 
   
    if (abs(g) < norm2pearson_transition) {
      return normal_cdf(u | m, s);

    } else {
      // Original LogPearson3 parameterisation
      real alpha = 4 / g / g;
      real beta = 2 / g / s;
      real tau = m - alpha / beta;

      real x = sign(g) * (u  - tau) * abs(beta);
      real cdf = gamma_p(alpha, x);

      if(beta < 0)
          cdf = 1 - cdf;
      
      return cdf;
    }
}


// Log Pearson 3 
real logpearson3_lpdf(vector y, real m, real s, real g) {
    // Could drop the sum of log(y) as it is not affected by parameterisation
    return pearson3_lpdf(log(y) | m, s, g) - sum(log(y));
}


// Generalized Pareto
real genpareto_lpdf(vector y, real tau, real alpha, real kappa) {
    int N = rows(y);
    real kappa_transition = 1e-6; 

    vector[N] z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        z = -1. / kappa * log(1 - kappa * z);
    }

    return -(1. - kappa) * sum(z) - N * log(alpha);
}

real genpareto_cdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        z = -1. / kappa * log(1 - kappa * z);
    }

    return 1. - exp(-z);    
}

// Generalized logistic
real genlogistic_lpdf(vector y, real tau, real alpha, real kappa) {
    int N = rows(y);
    real kappa_transition = 1e-6; 

    vector[N] z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        z = -1. / kappa * log(1. - kappa * z);
    }

    return -(1. - kappa) * sum(z) - 2. * sum(log(1 + exp(-z))) - N * log(alpha);
}

real genlogistic_cdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        z = -1. / kappa * log(1. - kappa * z);
    }

    return 1. / (1. + exp(-z));    
}

// ------- Marginal functions -----------------------------
// 1=Gumbel, 2=LogNormal, 3=GEV, 4=LogPearson3, 5=Normal, 6=Generalized pareto
// 7=Generalized logistic, 8=Gamma

real marginal_lpdf(vector x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_lpdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_lpdf(x | locn, scale);
    }
    else if(marginal==3){
        return gev_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==4){
        return logpearson3_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==5){
        return normal_lpdf(x | locn, scale);
    }
    else if(marginal==6){
        return genpareto_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==7){
        return genlogistic_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==8){
        // Assumes that location and scale parameters are the mean 
        // and variance of Gamma distribution 
        // assume loc = mean and beta = 1/scale
        // hence alpha=mean/scale
        // See https://en.wikipedia.org/wiki/Gamma_distribution
        return gamma_lpdf(x | locn / scale, 1./scale);
    }

    return not_a_number();
}

real marginal_cdf(real x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_cdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_cdf(x | locn, scale);
    }
    else if(marginal==3){
        return exp(gev_lcdf(x | locn, scale, shape1));
    }
    else if(marginal==4){
        return pearson3_cdf(log(x) | locn, scale, shape1);
    }
    else if(marginal==5){
        return normal_cdf(x | locn, scale);
    }
    else if(marginal==6){
        return genpareto_cdf(x | locn, scale, shape1);
    }
    else if(marginal==7){
        return genlogistic_cdf(x | locn, scale, shape1);
    }
    else if(marginal==8){
        return gamma_cdf(x | locn/scale, 1.0/scale);
    }
    return not_a_number();
}

real marginal_lcdf(real x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_lcdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_lcdf(x | locn, scale);
    }
    else if(marginal==3){
        return gev_lcdf(x | locn, scale, shape1);
    }
    else if(marginal==4){
        return log(pearson3_cdf(log(x) | locn, scale, shape1));
    }
    else if(marginal==5){
        return normal_lcdf(x | locn, scale);
    }
    else if(marginal==6){
        return log(genpareto_cdf(x | locn, scale, shape1));
    }
    else if(marginal==7){
        return log(genlogistic_cdf(x | locn, scale, shape1));
    }
    else if(marginal==8){
        return gamma_lcdf(x | locn/scale, 1.0/scale);
    }
    return not_a_number();
}




