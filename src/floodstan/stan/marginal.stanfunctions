 real sign(real x) {
    return x > 0 ? 1 : (x < 0 ? -1 : 0);
 }

// -------------- GEV distribution ------------------------------
// tau Bounds when kappa > 0 : [ymax-alpha/kapp, +infty[
// tau Bounds when kappa < 0 : ]-infty, ycensor-alpha/kapp]

real gev_lpdf(vector y, real tau, real alpha, real kappa){
    int N = rows(y);
    real logalpha = log(alpha);
    vector[N] u = (y - tau) / alpha;
    vector[N] v;

    // Threshold to transition from GEV to Gumbel
    real GEV2Gumbel_trans = 1e-10;

    real y0 = tau + alpha / kappa;
    if(kappa < -GEV2Gumbel_trans) {
        real ymin = min(y);
        if(ymin < y0)
            reject("[gev_lpdf] min(y) (", ymin, ") is lower than y0 (", y0, 
                   ") with tau=", tau, " alpha=", alpha, " kappa=", kappa);
    }
    else if (kappa > GEV2Gumbel_trans){
        real ymax = max(y);
        if(ymax > y0)
            reject("[gev_lpdf] max(y) (", ymax, ") is greater than y0 (", y0,
                   ") with tau=", tau, " alpha=", alpha, " kappa=", kappa);
    }
    
    if(abs(kappa) > GEV2Gumbel_trans) {
        // This is GEV log pdf
        v = -pow(1 - kappa * u, 1 / kappa);
        return -N * logalpha + sum(v + (1 / kappa - 1) * log(1 - kappa * u));

    } else {
        // This Gumbel log pdf
        return -N * logalpha - sum(u + exp(-u));
    }
}

real gev_lcdf(real y, real tau, real alpha, real kappa){
    real u = (y - tau) / alpha;
    real v;
   
    // Threshold to transition from GEV to Gumbel
    real GEV2Gumbel_trans = 1e-10;

    real y0 = tau + alpha / kappa;
    if(kappa < -GEV2Gumbel_trans && y < y0) {
       reject("[gev_lcdf] y (", y, ") is lower than y0 (", y0, 
              ") with tau=", tau, " alpha=", alpha, " kappa=", kappa);
    }
    else if (kappa > GEV2Gumbel_trans && y > y0){
       reject("[gev_lcdf] y (", y, ") is greater than y0 (", y0,
              ") with tau=", tau, " alpha=", alpha, " kappa=", kappa);
    }
 
    if(abs(kappa) > GEV2Gumbel_trans) {
        return -pow(1. - kappa * u, 1. / kappa);
    } else {
        return -exp(-u);
    }
}

// -------------- Pearson3 and LogPearson3 distributions -------------
// equivalent to a shifted Gamma distribution in log space

real logpearson3_lpdf(vector y, real m, real s, real g) {
    int N = rows(y);

    // transition from Pearson3 to Normal
    real n2p_trans = 1e-6;

    real abs_g = abs(g);
    real sign_g = sign(g);
   
    if(abs_g < n2p_trans) {
        return lognormal_lpdf(y | m, s);

    } else {
        // Original LogPearson3 parameterisation
        real alpha = 4 / g / g;
        real beta = 2 / g / s;
        real abs_beta = abs(beta);
        real tau = m - 2 * s / g;

        vector[N] ly = log(y);
        vector[N] u = sign_g * (ly - tau);
        real umin = min(u);
        if(umin < 0) {
            reject("[logpearson3_lpdf] umin (", umin, ") < 0 with m=", m, 
                   " logs=", log(s), " g=", g);
        }

        return gamma_lpdf(u | alpha, abs_beta) - sum(ly);
    }
}

// -- Functions needed for the approximation of incomplete gamma function
//    when alpha is large (say>100) and computation of gamma(alpha) is 
//    leading to overflow
// 
//    Temme, N. M. (1987). On the computation of the incomplete gamma 
//    functions for large values of the parameters. 
//    In Algorithms for approximation (pp. 479-489).
// 
//    Temme, N. M. (1994). A set of algorithms for the incomplete gamma 
//    functions. Probability in the Engineering and Informational 
//    Sciences, 8(2), 291-307.
//
// Approx of the function gamma star defined as
// Gs(x) = sqrt(a/2pi).exp(a).a^(-a).Gamma(a)
//
real gamma_star(real alpha) {
    real num = 0;
    real den = 0;

    // Coefficients from Temme (1987)
    array[4] real ak = {5.115471897484e-2, 4.990196893575e-1,
                        9.404953102900e-1, 9.999999625957e-1};

    array[4] real bk = {1.544892866413e-2, 4.241288251916e-1,
                        8.571609363101e-1, 1.000000000000e+0};
    
    for(i in 1:4){
        num = num * alpha + ak[5-i];
        den = den * alpha + bk[5-i];
    }

    return num/den;
}

real gamma_cdf_temme(real x, real alpha) {
    array[15] real fm = {-3.33333333e-01,  8.33333333e-02, -1.48148148e-02,
        1.15740741e-03,  3.52733686e-04, -1.78755144e-04,  3.91926318e-05,
       -2.18544851e-06, -1.85406221e-06,  8.29671134e-07, -1.76659527e-07,
        6.70785354e-09,  1.02618098e-08, -4.38203602e-09,  9.14769958e-10 };
    
    int Napprox = 14;
    array[Napprox+1] real bm;

    // First term of the approximation
    real lam = x / alpha;
    real eta = sqrt(2 * (lam - 1. - log(lam)));
    eta = lam < 1 ? -eta : eta;
    real cdf0 = erfc(-eta * sqrt(alpha / 2.)) / 2.;

    // Approximation coefficients to compute the residual
    bm[Napprox+1] = fm[Napprox+1];
    bm[Napprox] = fm[Napprox];
    real f;
    for(i in 1:Napprox-1){
        int mb = Napprox-i;
        f = mb>0 ? fm[mb] : 1.0; 
        bm[mb] = f + (mb + 1.) / alpha * bm[mb+2];
    }
    
    // Compute residual
    real S = 0;
    for(ms in 1:Napprox)
        S += bm[ms] * pow(eta, ms - 1.);

    real A = exp(-alpha * eta * eta / 2.) / sqrt(2. * pi() * alpha);
    real GS = gamma_star(alpha);
    real R = A * S / GS;
    
    // .. put it together
    return cdf0 - R;
}

real logpearson3_cdf(real y, real m, real s, real g){
    real cdf;
    
    // transition from Pearson3 to Normal
    real n2p_trans = 1e-6;
    
    // Threshold to transition from pearson to approx
    // for cdf computation. This is a high threshold
    // due to very slow computation of gamma function 
    // for high x and alpha in Stan. 
    real approx_trans = 0.1; 

    // Original LogPearson3 parameterisation
    real alpha = 4. / g / g;
    real beta = 2. / g / s;
    real abs_beta = abs(beta);
    real tau = m - 2 * s / g;
    
    real abs_g = abs(g);
    real sign_g = sign(g);

    // Important: here, the definition of x includes abs_beta
    // contrary to what is done for logpearson3_logpdf.
    // This is done because Temme's approximation does not have a 
    // scaling parameters, and hence scaling must be included 
    // in the x variable. Consequently, the stan function is
    // used with a scale parameter set to 1.
    real x = beta * (log(y) - tau);
    
    if(x < 0 && abs_g > n2p_trans) 
        reject("[logpearson3_cdf] x (", x, ") < 0 with m=", m, 
               " logs=", log(s), " g=", g);

    if(abs_g < n2p_trans) {
        return lognormal_cdf(y | m, s);
    }
    else if(abs_g > approx_trans) {
        // Stan gamma cdf is fine
        cdf = gamma_cdf(x | alpha, 1.);
    }    
    else {
        // Stan gamma is very slow. Use Temme's approximation
        cdf = gamma_cdf_temme(x, alpha);
    } 

    if(beta < 0)
        cdf = 1 - cdf;
    
    return cdf;
}

// -------------- Generalized Pareto -------------
real genpareto_lpdf(vector y, real tau, real alpha, real kappa) {
    int N = rows(y);
    real kappa_transition = 1e-6; 

    vector[N] z = (y - tau) / alpha;

    if(abs(kappa) > kappa_transition){
        // Check y are all in support
        real ymin = min(y);
        real ymax = max(y);
        if(kappa > 0 && (ymin < tau || ymax > tau + alpha / kappa))
            reject("[genpareto_lpdf] ymin (", ymin, ") < tau or ymax (",  ymax, 
                   ") > tau+alpha/kappa",
                   " with tau=", tau, " alpha=", alpha, " kappa=", kappa);

        else if(kappa < 0 && ymin < tau)
            reject("[genpareto_lpdf] ymin (", ymin, ") < tau with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);

        z = -1. / kappa * log1m(kappa * z);
    }

    return -(1. - kappa) * sum(z) - N * log(alpha);
}

real genpareto_cdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;

    if(abs(kappa) > kappa_transition){
        if(kappa > 0 && ((y < tau) || (y > tau + alpha / kappa)))
            reject("y (", y, ") < tau or y (", y, ") > tau+alpha/kappa",
                   " with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);

        else if(kappa < 0 && (y < tau))
            reject("y (", y, ") < tau with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);
 
        z = -1. / kappa * log1m(kappa * z);
    }
    return 1. - exp(-z);    
}

real genpareto_lcdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        if(kappa > 0 && ((y < tau) || (y > tau + alpha / kappa)))
            reject("[gen_pareto_lcdf] y (", y, ") < tau or y (", y,
                   ") > tau+alpha/kappa with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);

        else if(kappa < 0 && (y < tau))
            reject("[gen_pareto lcdf] y (", y, ") < tau with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);
 
        z = -1. / kappa * log1m(kappa * z);
    }
    return log1m_exp(-z);
}

// -------------- Generalized Logistic -------------
real genlogistic_lpdf(vector y, real tau, real alpha, real kappa) {
    int N = rows(y);
    real kappa_transition = 1e-6; 

    vector[N] z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        real y0 = kappa < 0 ? min(y) : max(y);
        real yt = tau + alpha / kappa;
        if(kappa * (y0 - yt) > 0)
            reject("[genlogistic_lpdf] y0 (", y0, ") incompatible with yt (", 
                   yt, ") if tau=", tau, " alpha=", alpha, " kappa=", kappa);
 
        z = -1. / kappa * log1m(kappa * z);
    }
    return -(1. - kappa) * sum(z) - 2. * sum(log(1 + exp(-z))) - N * log(alpha);
}

real genlogistic_cdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        real yt = tau + alpha / kappa;
        if(kappa * (y - yt) > 0)
            reject("[genlogistic_cdf] y (", y, ") incompatible with yt (", 
                   yt, ") if tau=", tau, " alpha=", alpha, " kappa=", kappa);

        z = -1. / kappa * log1m(kappa * z);
    }
    return 1. / (1. + exp(-z));    
}

real genlogistic_lcdf(real y, real tau, real alpha, real kappa) {
    real kappa_transition = 1e-6; 

    real z = (y - tau) / alpha;
    if(abs(kappa) > kappa_transition){
        real yt = tau + alpha / kappa;
        if(kappa * (y - yt) > 0)
            reject("y (", y, ") incompatible with yt (", yt, ") with tau=", tau, 
                   " alpha=", alpha, " kappa=", kappa);

        z = -1. / kappa * log1m(kappa * z);
    }
    return -log1p_exp(-z);
}


// ------- Marginal functions -----------------------------
// 1=Gumbel, 2=LogNormal, 3=GEV, 4=LogPearson3, 5=Normal, 6=Generalized pareto
// 7=Generalized logistic, 8=Gamma

real marginal_lpdf(vector x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_lpdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_lpdf(x | locn, scale);
    }
    else if(marginal==3){
        return gev_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==4){
        return logpearson3_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==5){
        return normal_lpdf(x | locn, scale);
    }
    else if(marginal==6){
        return genpareto_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==7){
        return genlogistic_lpdf(x | locn, scale, shape1);
    }
    else if(marginal==8){
        // Assumes that location and scale parameters are the mean 
        // and variance of Gamma distribution 
        // assume loc = mean and beta = 1/scale
        // hence alpha=mean/scale
        // See https://en.wikipedia.org/wiki/Gamma_distribution
        return gamma_lpdf(x | locn / scale, 1./scale);
    }

    return not_a_number();
}

real marginal_cdf(real x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_cdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_cdf(x | locn, scale);
    }
    else if(marginal==3){
        return exp(gev_lcdf(x | locn, scale, shape1));
    }
    else if(marginal==4){
        return logpearson3_cdf(x | locn, scale, shape1);
    }
    else if(marginal==5){
        return normal_cdf(x | locn, scale);
    }
    else if(marginal==6){
        return genpareto_cdf(x | locn, scale, shape1);
    }
    else if(marginal==7){
        return genlogistic_cdf(x | locn, scale, shape1);
    }
    else if(marginal==8){
        return gamma_cdf(x | locn/scale, 1.0/scale);
    }
    return not_a_number();
}

real marginal_lcdf(real x, int marginal, real locn, real scale, real shape1)
{
    if(marginal==1){
        return gumbel_lcdf(x | locn, scale);
    }
    else if(marginal==2){
        return lognormal_lcdf(x | locn, scale);
    }
    else if(marginal==3){
        return gev_lcdf(x | locn, scale, shape1);
    }
    else if(marginal==4){
        return log(logpearson3_cdf(x | locn, scale, shape1));
    }
    else if(marginal==5){
        return normal_lcdf(x | locn, scale);
    }
    else if(marginal==6){
        return genpareto_lcdf(x | locn, scale, shape1);
    }
    else if(marginal==7){
        return genlogistic_lcdf(x | locn, scale, shape1);
    }
    else if(marginal==8){
        return gamma_lcdf(x | locn/scale, 1.0/scale);
    }
    return not_a_number();
}




