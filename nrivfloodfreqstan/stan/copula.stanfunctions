
// Correlation parameterisation
// 1=Gumbel, 2=Clayton, 3=Gaussian
real corr2param(int copula, real rho) {

    real rho_min = 0.01;
    real rho_max = 0.95;

    // Lower threshold for Gaussian copula due to 
    // limitation in cdf approximation algorithm
    if(copula==3)
        rho_max = 0.8;

    if(rho < rho_min)
        reject("Copula ", copula, ": rho (", rho, ") < ", rho_min);
    if(rho > rho_max)
        reject("Copula ", copula, ": rho (", rho, ") > ", rho_max);

    if(copula==1) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 172
        return 1.0/(1-rho);
    }

    else if (copula==2) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 168
        return 2*rho/(1-rho);
    }

    else if (copula==3) {
        // Using Kendall Tau as parameter
        return sin(pi()*rho/2);
    }

    return not_a_number();
}


// ------- Copula functions -----------------------------
// 1=Gumbel, 2=Clayton, 3=Gaussian

real copula_lcdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        real m = corr2param(copula, rho);
        vector[N] logu = log(uv[:, 1]);
        vector[N] logv = log(uv[:, 2]);
        vector[N] a = pow(logu, m)+pow(logv, m);
        return sum(-pow(a, 1.0/m));
    }

    else if (copula==2) {
        real theta = corr2param(copula, rho);
        vector[N] powu = pow(uv[:, 1], -theta);
        vector[N] powv = pow(uv[:, 2], -theta);
        return sum(-log(powu+powv-1)/theta);
    }

    else if (copula==3) {
        // Translation of the matlab code from Alan Genz
        // https://www.math.wsu.edu/faculty/genz/software/matlab/bvn.m
        // Note that this code was supposed to work for correlation < 0.925
        // we are using it upto correlation = 0.951
        real r = corr2param(copula, rho);
        real tp = 2*pi();
        vector[N] h = -inv_Phi(uv[:, 1]);
        vector[N] k = -inv_Phi(uv[:, 2]);
        vector[N] hk = h.*k;

        array[10] real w = zeros_array(10);
        array[10] real x = zeros_array(10);

        if(abs(r) < 0.3){
            // Gauss Legendre points and weights, n =  6
            w[1:3] = {0.1713244923791705, 0.3607615730481384, 0.4679139345726904};
            x[1:3] = {0.9324695142031522, 0.6612093864662647, 0.2386191860831970};
        }
        else if(abs(r) < 0.75) {
            // Gauss Legendre points and weights, n = 12
            w[1:3] = {0.04717533638651177, 0.1069393259953183, 0.1600783285433464};
            w[4:6] = {0.2031674267230659, 0.2334925365383547, 0.2491470458134029};

            x[1:3] = {0.9815606342467191, 0.9041172563704750, 0.7699026741943050};
            x[4:6] = {0.5873179542866171, 0.3678314989981802, 0.1252334085114692};
        }   
        else {
            // Gauss Legendre points and weights, n = 20
            w[1:3] = {0.01761400713915212, .04060142980038694, 0.06267204833410906};
            w[4:6] = {0.08327674157670475, 0.1019301198172404, 0.1181945319615184};
            w[7:9] = {0.1316886384491766, 0.1420961093183821, 0.1491729864726037};
            w[10] = 0.1527533871307259;

            x[1:3] = {0.9931285991850949, 0.9639719272779138, 0.9122344282513259};
            x[4:6] = {0.8391169718222188, 0.7463319064601508, 0.6360536807265150};
            x[7:9] = {0.5108670019508271, 0.3737060887154196, 0.2277858511416451};
            x[10] = 0.07652652113349733;
        }

        vector[N] hs = (h.*h+k.*k)/2;
        real asr = asin(r)/2;
        real sn;
        int j;
        vector[N] bvn = zeros_vector(N);
        for(i in 1:20){
            if(i<=10) {
                j = i;
                sn = sin(asr*(1+x[j]));
            }    
            else {
                j = i-10;
                sn = sin(asr*(1-x[j]));
            }    
            bvn = bvn + exp((sn*hk-hs)/(1-sn*sn))*w[j];
        }

        return sum(log(bvn*asr/tp+Phi(-h).*Phi(-k)));
    }

    return not_a_number();
}

real copula_lpdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        real m = corr2param(copula, rho);
        vector[N] logu = log(uv[:, 1]);
        vector[N] logv = log(uv[:, 2]);
        vector[N] a = pow(logu, m)+pow(logv, m);
        return sum(-pow(a, 1.0/m)
                        -m*(logu+logv)
                        +(1.0/m-2)*log(a)
                        +log(m-1+pow(a, 1.0/m))
                    );
    }

    else if (copula==2) {
        real theta = corr2param(copula, rho);

        // TODO
        reject("Clayton lpdf not implemented.");
    }

    else if (copula==3) {
        real corr = corr2param(copula, rho);
        real corr2 = 1-corr*corr;
        vector[N] p = inv_Phi(uv[:, 1]);
        vector[N] q = inv_Phi(uv[:, 2]);
        vector[N] psq = p.*p;
        vector[N] qsq = q.*q;

        return sum(-log(corr2)*N/2
                    +corr*corr2*(p.*q)
                    +0.5*(psq+qsq)*(1-corr2));
    }
    
    return not_a_number();
}

real copula_lpdf_ucensored(real ucensor, vector v, int copula, real rho){
    int N = rows(v);

    if(copula==1) {
        real m = corr2param(copula, rho);
        vector[N] a = pow(log(ucensor), m)+pow(log(v), m);
        return sum(-pow(a, 1.0/m)
                    +(1.0/m-1)*log(a)
                    -m*v
                );
    }

    else if (copula==2) {
        real theta = corr2param(copula, rho);

        // TODO
        reject("Clayton lpdf_ucensored not implemented.");
    }

    else if (copula==3) {
        real corr = corr2param(copula, rho);
        real pcensor = inv_Phi(ucensor);
        vector[N] q = inv_Phi(v);
        return sum(log(Phi((q-corr*pcensor)/sqrt(1-corr*corr))));
    }

    return not_a_number();
}

