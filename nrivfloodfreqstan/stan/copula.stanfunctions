
// Parameterisation
// 1=Gumbel, 2=Clayton, 3=Gaussian
real correlation(int copula, real rho) {
    if(rho < -0.999)
        reject("rho (", rho, ") <-0.999");
    if(rho > 0.999)
        reject("rho (", rho, ") >0.999");

    if(copula==1) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 172
        return 1/(1-rho);
    }

    else if (copula==2) {
        // Using Kendall Tau as parameter
        // See Joe (2014), page 168
        return 2*rho/(1-rho);
    }

    else if (copula==3) {
        // Gaussian correlation - no re-parameterisation
        return rho;
    }

    return not_a_number();
}


// Gaussian copula functions:
// see  Zvi Drezner & G. O. Wesolowsky (1990) On the computation of the
// bivariate normal integral, 
// Journal of Statistical Computation and Simulation, 35:1-2, 101-107, DOI: 10.1080/00949659008811236
// https://www.tandfonline.com/doi/pdf/10.1080/00949659008811236?needAccess=true
// 
//FUNCTION BV(H 1 ,H2,R) 
//DIMENSION X(5),W(5) 
//DATA X/.04691008,.23076534,.5,.76923466,.95308992/ 
//DATA W/.O18854042,.038088059,.0452707394,.038088059,.018854042/ 
//H12 =(Hl*Hl+ H2*H2)/2. 
//H3 = H1 *H2 
//BV = 0. 
//DO 1 I= 1,5 
//RR = R*X(I) 
//RR2= 1.-RR*RR 
//1 BV = BV + W(I)*EXP((RR*H3 - H12)/RR2)/SQRT(RR2) 
//BV = BV*R + GAUSS(H 1)*GAUSS(H2) 
//RETURN 
//END


// ------- Copula functions -----------------------------
// 1=Gumbel, 2=Clayton, 3=Gaussian

real copula_lcdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        real m = correlation(copula, rho);
        vector[N] logu = log(uv[:, 1]);
        vector[N] logv = log(uv[:, 2]);
        vector[N] a = pow(logu, m)+pow(logv, m);
        return sum(-pow(a, 1/m));
    }

    else if (copula==2) {
        real theta = correlation(copula, rho);
        vector[N] powu = pow(uv[:, 1], -theta);
        vector[N] powv = pow(uv[:, 2], -theta);
        return sum(-log(powu+powv-1)/theta);
    }

    else if (copula==3) {
        real corr = correlation(copula, rho);

        // See copula function above
        array[5] real A = {0.04691008, 0.23076534, 0.5, 0.76923466, 0.95308992};
        array[5] real B = {0.018854042, 0.038088059, 0.0452707394, 0.038088059, 0.018854042};

        matrix[N, 2] q;
        q[:, 1] = inv_Phi(uv[:, 1]);
        q[:, 2] = inv_Phi(uv[:, 2]);

        vector[N] h12 = (q[:, 1].*q[:, 1]+q[:, 2].*q[:, 2])/2.;
        vector[N] h3 = q[:, 1].*q[:, 2];
        vector[N] bv = zeros_vector(N);
        real rr, rr2;

        for(i in 1:5) {
            rr = corr*A[i];
            rr2 = 1.-rr*rr;
            bv += B[i]*exp((rr*h3 - h12)/rr2)/sqrt(rr2);
        }
        return sum(log(bv*corr + uv[:, 1].*uv[:, 2]));
    }

    return not_a_number();
}

real copula_lpdf(matrix uv, int copula, real rho){
    int N = rows(uv);

    if(copula==1) {
        real m = correlation(copula, rho);
        vector[N] logu = log(uv[:, 1]);
        vector[N] logv = log(uv[:, 2]);
        vector[N] a = pow(logu, m)+pow(logv, m);
        // CHECK THAT!!
        return sum(-pow(a, 1/m)
                        -m*(logu+logv)
                        +(1/m-2)*log(a)
                        +log(m-1+pow(a, 1/m))
                    );
    }

    else if (copula==2) {
        real theta = correlation(copula, rho);

        // TODO
        return 0;
    }

    else if (copula==3) {
        real corr = correlation(copula, rho);
        matrix[N, 2] q = inv_Phi(uv);
        vector[2] mu = zeros_vector(2);
        matrix[2, 2] Sigma = [[1, corr], [corr, 1]];
        real lp = 0;
        for(i in 1:N)
            lp += multi_normal_lpdf(q[i, :] | mu, Sigma);
        return lp;
    }
    
    return not_a_number();
}

real copula_lpdf_ucensored(real ucensor, vector v, int copula, real rho){
    int N = rows(v);

    if(copula==1) {
        real m = correlation(copula, rho);
        vector[N] a = pow(log(ucensor), m)+pow(log(v), m);
        return sum(-pow(a, 1/m)
                    +(1/m-1)*log(a)
                    -m*v
                );
    }

    else if (copula==2) {
        real theta = correlation(copula, rho);

        // TODO
        return 0;
    }

    else if (copula==3) {
        real corr = correlation(copula, rho);
        real qcensor = inv_Phi(ucensor);
        vector[N] q = inv_Phi(v);
        return sum(log(Phi((q-corr*qcensor)/sqrt(1-corr*corr))));
    }

    return not_a_number();
}

